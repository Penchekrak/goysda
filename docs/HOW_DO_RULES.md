# Как Реализованы Правила Го: Глубокое погружение

В этом документе детально описываются алгоритмы, лежащие в основе ключевых механик игры.

## 1. Механизм "Прилипания" Камней (Snapping)

Эта система отвечает за то, куда именно будет поставлен камень. Логика разделена на два основных сценария, управляемых из `goysda/snapper.py`.

**Где это в коде?**
*   Диспетчер: `goysda/snapper.py`, функция `snap_stone`.
*   Алгоритмы: `goysda/utils.py`, функции `compute_closest_snap_position`, `compute_double_touch_points`, `compute_border_touch_points` и др.

### Сценарий 1: Простое размещение (режим "Nearest possible")

Этот режим активен, когда игрок выбирает размещение в ближайшей возможной точке (`snap_to_color` = `False`).

1.  **Проверка на пересечение:** Сначала `snap_stone` вызывает `utils.stone_intersects_others(x, y, ...)` для координат курсора `(x, y)`.
2.  **Алгоритм `stone_intersects_others`:**
    *   Проверяет, не выходит ли камень за пределы доски.
    *   Затем в цикле перебирает все уже установленные камни (`game_state.placed_stones`).
    *   Для каждого камня вычисляется квадрат расстояния между его центром и центром нового камня. Если это расстояние меньше квадрата двух радиусов (`4 * r^2`), считается, что есть пересечение.
3.  **Результат:**
    *   Если пересечений нет, `snap_stone` возвращает исходные координаты курсора.
    *   Если пересечение есть, активируется Сценарий 2.

### Сценарий 2: "Умное" прилипание (Snap to color / Занятое место)

Этот режим включается, если игрок выбрал прилипание к своему/чужому цвету, или если место под курсором уже занято.

1.  **Вызов `compute_closest_snap_position`:** Это ядро механизма. Функция ищет идеальное место для постановки камня.
2.  **Сбор кандидатов:** Функция собирает ОГРОМНЫЙ список всех возможных "особых" точек на доске, вызывая другие функции:
    *   **`compute_double_touch_points`:** Находит все точки, где новый камень может коснуться двух уже существующих. Для каждой пары камней она решает простую геометрическую задачу: находит точки пересечения двух окружностей радиусом `2R` с центрами в центрах этих камней.
    *   **`compute_border_touch_points`:** Аналогично, находит точки касания одного камня и одной из четырех границ доски.
    *   **`compute_perpendicular_touches`:** Для каждого существующего камня находит две точки, лежащие на линии, соединяющей этот камень и курсор, на расстоянии `2R`. Это позволяет "прилипнуть" к камню с любой стороны.
    *   **`compute_perpendicular_border_touches`:** То же самое, но для границ доски.
3.  **Фильтрация кандидатов:** Все сгенерированные точки-кандидаты снова проверяются через `stone_intersects_others`, чтобы отбросить те, которые приводят к пересечению.
4.  **Поиск ближайшей:** Из оставшихся валидных точек в цикле ищется та, у которой минимальное расстояние до курсора. Её координаты и возвращаются как результат.

---

## 2. Захват Групп (Killing)

Этот алгоритм определяет, какие камни должны быть сняты с доски после хода.

**Где это в коде?**
*   `goysda/game_state.py`, метод `handle_click` (инициация).
*   `goysda/utils.py`, функции `kill_groups_of_color`, `split_stones_by_groups`, `compute_group`, `group_has_dame`.

### Алгоритм шаг за шагом

1.  **Идентификация групп (`split_stones_by_groups` и `compute_group`):**
    *   Сразу после хода, `kill_groups_of_color` вызывает `split_stones_by_groups`, чтобы разделить все камни на доске на связанные группы.
    *   `split_stones_by_groups` работает с помощью `compute_group`, который реализует **поиск в ширину (BFS)**.
    *   Начиная со стартового камня, `compute_group` находит его "соседей" — камни того же цвета, центры которых находятся на расстоянии меньше `2*R + epsilon`. Эти соседи добавляются в группу и в очередь для дальнейшего поиска. Процесс продолжается, пока все связанные камни не будут найдены.

2.  **Проверка "жизни" группы (`group_has_dame`):**
    *   Это самый нетривиальный алгоритм. Для каждой найденной группы камней `kill_groups_of_color` вызывает `group_has_dame`, чтобы проверить, есть ли у нее хотя бы одна "свобода" (даме).
    *   **Определение "даме":** В этой игре "даме" — это не пустая точка сетки, а **любая теоретически возможная точка на доске, куда можно было бы поставить новый камень того же цвета так, чтобы он касался группы и не пересекал другие камни.**
    *   Для проверки этого `group_has_dame` генерирует все возможные точки касания для ВСЕХ камней в проверяемой группе (используя те же `compute_double_touch_points`, `compute_border_touch_points` и т.д., что и при snapping).
    *   Каждая такая сгенерированная точка-кандидат проверяется через `stone_intersects_others`.
    *   Если **хотя бы одна** из этих точек оказывается валидной (не пересекает другие камни), значит, у группы есть "даме". `group_has_dame` немедленно возвращает `True`, и группа считается "живой".

3.  **Удаление "мертвой" группы (`kill_group`):**
    *   Если `group_has_dame` перебрала все возможные точки касания и не нашла ни одной валидной, она возвращает `False`.
    *   В этом случае `kill_groups_of_color` вызывает `kill_group` для этой группы.
    *   `kill_group` просто удаляет все камни, принадлежащие этой "мертвой" группе, из основного списка `game_state.placed_stones`.

4.  **Правило Самоубийства:** Реализовано неявно. После хода игрока сначала проверяются на захват группы противника, а потом — группы самого игрока. Если его собственная группа после хода оказалась без "даме", она будет немедленно удалена.

---

## 3. Подсчет Территории (Диаграмма Вороного)

Подсчет территории происходит динамически и основан на мощном геометрическом инструменте.

**Где это в коде?**
*   `goysda/game_state.py`, метод `calculate_voronoi_polygons`.

### Алгоритм

1.  После каждого хода или даже движения мыши вызывается `calculate_voronoi_polygons`.
2.  Используя библиотеку `shapely`, функция строит **Диаграмму Вороного** для всех камней на доске.
3.  Диаграмма Вороного — это разбиение плоскости на регионы (полигоны) на основе расстояния до точек из заданного набора (в нашем случае — центров камней). Каждому камню соответствует регион, состоящий из всех точек плоскости, которые находятся ближе к этому камню, чем к любому другому.
4.  Территория каждого игрока вычисляется как **сумма площадей** тех полигонов Вороного, которые "принадлежат" камням этого игрока.
5.  Итоговая площадь нормируется (делится на площадь одного камня `πR²`), чтобы получить счет в очках, отображаемый в интерфейсе. 