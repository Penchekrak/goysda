# Как Реализованы Правила Го

В этом документе описывается, как ключевые механики и правила игры Го реализованы в коде проекта.

## Общий Принцип

Основным "мозгом" игры является класс `GameState` в файле `goysda/game_state.py`. Он хранит всю информацию о текущем состоянии доски и отвечает за ее обновление. Большинство сложных геометрических и логических вычислений вынесены во вспомогательные функции в файле `goysda/utils.py`.

---

## 1. Постановка Камня и Смена Хода

Эта логика является отправной точкой для всех остальных правил.

**Где это в коде?**
*   `goysda/game_state.py`, метод `handle_click(self, action)`

**Как это работает?**
1.  Когда игрок кликает мышью, вызывается `handle_click`.
2.  Сначала определяется точное местоположение нового камня с помощью `_snap_stone`, которое, в свою очередь, вызывает `snap_stone` из `goysda/snapper.py` для выравнивания по сетке или другим камням.
3.  Новый камень (`Stone`) создается и добавляется в список `self.placed_stones`.
4.  Сразу после этого инициируется проверка на захват камней (см. следующий пункт).
5.  В самом конце метода ход передается другому игроку: `self.player_to_move = (self.player_to_move + 1) % 2`.

---

## 2. Захват Камней (Взятие групп)

Это самая сложная часть правил. В отличие от традиционного подхода на сеточной доске, здесь используется геометрический анализ.

**Где это в коде?**
*   Инициация: `goysda/game_state.py`, метод `handle_click`.
*   Основная логика: `goysda/utils.py`, функции `kill_groups_of_color`, `group_has_dame`, `compute_group` и `kill_group`.

**Как это работает?**
После каждого хода в `handle_click` последовательно вызывается функция `kill_groups_of_color` сначала для цвета противника, а затем для цвета текущего игрока (для проверки на самоубийственный ход).

1.  **`kill_groups_of_color(color, ...)`**:
    *   Эта функция получает все камни указанного `color`.
    *   Она объединяет их в группы с помощью `split_stones_by_groups`.
    *   Для каждой группы она вызывает `group_has_dame`, чтобы проверить, есть ли у группы "свободы" (даме).

2.  **`group_has_dame(group, ...)`**:
    *   **Это ключевая функция.** Она определяет, "жива" ли группа.
    *   Она НЕ считает "глаза" в классическом понимании. Вместо этого она геометрически ищет хотя бы одну точку на доске, куда можно было бы поставить новый камень того же цвета, чтобы он касался данной группы, но не пересекался с другими камнями.
    *   Если хотя бы одна такая "точка касания" (свобода) найдена, функция возвращает `True`, и группа считается живой.
    *   Если ни одной такой точки найти не удалось, группа считается "мертвой" (без свобод).

3.  **`kill_group(group, ...)`**:
    *   Если `group_has_dame` вернула `False`, вызывается эта функция.
    *   Она просто удаляет все камни, принадлежащие "мертвой" группе, из основного списка `game_state.placed_stones`.

Таким образом, правило "самоубийства" реализовано неявно: если после своего хода группа игрока оказывается без свобод, она тут же снимается с доски.

---

## 3. Подсчет Территории

Подсчет территории в данной реализации также нетривиален и основан на геометрии, а не на заполнении областей.

**Где это в коде?**
*   `goysda/game_state.py`, метод `calculate_voronoi_polygons`.

**Как это работает?**
1.  После каждого хода или движения мыши вызывается `calculate_voronoi_polygons`.
2.  Эта функция использует библиотеку `shapely` для построения **Диаграммы Вороного** для всех камней на доске.
3.  Диаграмма Вороного делит всю доску на полигоны таким образом, что каждая точка внутри полигона ближе к "своему" камню, чем к любому другому.
4.  Территория каждого игрока — это просто сумма площадей тех полигонов Вороного, которые принадлежат камням этого игрока.
5.  Полученная площадь затем нормируется (делится на площадь одного камня), чтобы получить итоговый счет в "очках".

Этот подход позволяет динамически и очень точно оценивать влияние каждого камня на доску в режиме реального времени. 